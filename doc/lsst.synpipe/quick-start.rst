#########################
Synpipe Quick Start Guide
#########################

Synpipe is a tool in the LSST Science Pipelines that is used to insert fake objects
into data that is to be processed. Though Synpipe is not
the only way to insert fake objects into the stack, anyone can create a custom
fake object tasks, it provides a quick and convenient method for the most common
use cases. This document aims to make a user able to start using Synpipe in the
shortest time possible while providing enough detail to understand the over all
workflow.

An important note is that this tool was initially created for the HSC survey,
and although the LSST stack supports many different cameras, at this point Synpipe
is currently limited to working with HSC data repositories.

This guide will assume processing will be done though the ``pipe_drivers`` scripts.
All the information is generally applicable, but configuration paths will change
relative to what task is run in place of pipe_driver tasks.

Generating A Catalog
====================

For many of the fake object insertion tasks it is necessary to pre-generate a
catalog of fake objects from which the insertion process can draw from. This is
most important when fake objects are to be placed at specific locations in the
sky such that they are inserted in the same place consistently in each input
frame.

Generating an input catalog for both stars and galaxies are done with the
``makeSourceList.py`` command, but differ on some of the inputs. For either type
of fake object ``makeSourceList.py`` takes an input repository as its first
positional argument and the switch ``--id`` which is used to specify the data from
which spatial (in ra, dec) coordinates will be generated. All of the coordinates
generated will lie inside the bonding box defined by ``--id``, and thus it is most
common to use the tract of a coaddition as the id argument. If fake objects are
to be inserted and measured such that single frame processing is the last step,
a single frame id may be used, but a different input catalog will need to be
generated for each single frame to be processed. In general it is easier to
simply specify the spatial tract a single frame lies in. Generating a larger
input catalog than is necessary is not a problem, provided there is sufficient
numbers of objects to ensure the desired density.

Additional configuration for this script is done using the standard LSST
configuration procedure. Configurations can either be specified on the
command-line using ``-c`` or with a config file. The nuances of this system are
left to another LSST guide on configurations. This guide will assume everything
is to be entered on the command line behind a ``-c`` switch for each configuration.
There are many configurations available to control the scripts behavior, but
this guide will highlight the most commonly used.  A full list along with
descriptions can be found within the script.
Listed below are all the configurations that may be set:

- rhoFakes : Number of fakes per patch in the specified tract. Defaults to 500.
- inputCatalog : Catalog from which to draw input magnitudes, see below for appropriate settings for stars vs. galaxies
- outDir : Specify the file-system path that the output will be saved in

This script will not create the outDir if it does not already exist, the user
must create the output directory prior to running this script.

As this script is based on the LSST command line task, there is currently a quirk
where and output must be specified with either ``--output`` or ``--rerun``, but this
directory is not really used for anything. This may change in a future version
but for now the output must be specified, but can safely be removed after.

A final caveat for using this command is that a valid ``skymap`` must already exist in the
input repo. This is different to the normal usage of ``pipe_drivers`` where the ``skymap``
is created just prior to making coadds. It should not be a problem to use the 
``makeSkyMap.py`` command prior to building the fake object catalog. Using the
``makeDiscreteSkyMap.py`` may be problematic if the input ids are not know. The reason a
``skymap`` is needed in the input is due to the way synpipe looks up the ranges of RA and
Dec which form a tract and patch. These ranges are used when selecting the positions 
where fake objects should be inserted.

egions in the sky
based on tract and patch when selecting the range of RA and DEC

A typical galaxy catalog can be generated with the following command

.. code-block:: bash

    makeSourceList.py <input repo> --rerun dummyOutput --id tract=<tract number> -c outDir=~/catalogOutput -c rhoFakes=700

Stars
-----

A stellar fake source candidate catalog is generated by suppling an astropy
fits table containing input magnitudes to the inputCat configuration
parameter. All columns that exist in the input catalog will be copied to the
candidate output catalog. This allows the most flexibility, where in the input
catalog can contain a single magnitude, or many columns corresponding to the
color of stars.

Galaxies
--------

The default configuration for inputCatalog is a galaxy catalog that is
pre-generated to correspond to real galaxy parameters as measured from the
COSMOS field. Most of the time this should be sufficient for fake galaxy
insertion and therefore this configuration need not be set. If this input catalog
does not meet some requirements, and input catalog containing columns which
correspond to galsim parameters should be supplied.

Single Frame Processing
=======================

Using Synpipe in single frame processing is as simple as specifying which fake
object task from Synpipe to use with the LSST fake object pipeline. Synpipe
provides the four following tasks:

- RandomStarFakeSourcesTask : Used to insert stars of a single magnitude at random positions in a frame
- RandomGalSimFakesTask : Used to insert galaxies from a catalog at random positions in an image
- PositionStarFakesTask : Insert stars from a star catalog at the positions defined in the catalog
- PositionGalSimFakesTask : Insert galaxies from a catalog at positions defined in the catalog

Each of these tasks have their own configurations to be set according to the
needs of the processing. Please see the individual task configs for all the
various options.

The only thing necessary to use one of these tasks with the LSST fake object
pipeline is to import the task, retarget the fake object task, and tell
singleFrameDriver to insert fake objects. The following example shows a
config file for singleFrameDriver that accomplishes this. Individual configs
will change with the task selected.

.. code-block:: python

    from lsst.synpipe.positionGalSimFakes import PositionGalSimFakesTask

    config.processCcd.calibrate.doInsertFakes = True
    config.processCcd.calibrate.insertFakes.retarget(PositionGalSimFakesTask)
    config.processCcd.calibrate.insertFakes.galList = "~/customFakeGalaxyCatalog.fits"
    config.processCcd.calibrate.insertFakes.maxMargin = 0
    config.processCcd.calibrate.insertFakes.addMask = True

When singleFrameDriver completes, fake objects will have been inserted into the
frames, and had all the measurement plugins run on them, as if they were any
regular sources. If this is the last step in data processing skip to the bottom
for the easiest way to extract fake sources from output catalogs.

If fake sources are added in single frame processing all additional processing
steps can happen as normal. There is no need to follow the Coaddition or Multiband
sections of this document.

Coaddition Processing
=====================

The good news here is that coaddition very similar to single frame processing.
The first step is to turn off detection in coaddDriver by setting

.. code-block:: py

    config.doDetection = False

This will make coaddDriver stop after processing, and not make any further
measurements. These coadds can then be used as a base for many different
processing runs each with their own set of fake objects inserted. This saves
computational times on measurements that would need to be duplicated in further
processing stages.

Adding fakes during multiBandDriver processing is almost the same as the process
as for singleFrameDriver. Import the desired task, retarget the fake object task
and set the configuration to add fakes to True. The one additional step is to set
the multibandDriver to run detections. This step needs to be done even if the
input repository was not created as above and has detections in it. Rerunning
the detection task is necessary so that the fake objects can be identified and
have measurements made on them. The relevant configs are shown below.

.. code-block:: py

    from lsst.synpipe.positionGalSimFakes import PositionGalSimFakesTask

    config.doDetection = True
    config.detectCoaddSources.doInsertFakes = True
    config.detectCoaddSources.insertFakes.retarget(PositionGalSimFakesTask)
    config.detectCoaddSources.insertFakes.galList = "~/customFakeGalaxyCatalog.fits"
    config.detectCoaddSources.insertFakes.maxMargin = 0
    config.detectCoaddSources.insertFakes.addMask = True

All of the inserted fake objects will be inserted into the coadd image, and have
entries in the measurement catalogs like any real object.

Extracting Fakes From Catalogs
==============================

The runMatchFakes.py script can be used to extract fake sources from a
measurement catalog, and place them into their own catalog. This script takes
the input data repository where the measurement catalog resides as its
first positional argument, and the visit or tract number as the second. If a
tract number is specified, the ``-f`` switch **must** be used to specify the desired
filter. To complete a repository dataid, the --ccd options is used to specify
the ccd number or patch id. The location the output will be written to is given
by the ``-o`` switch. The catalog of fakes to match against is specified with the
-c switch. These are the most commonly used options in extracting fake objects,
but there are other switches available which control additional parameters of
the matching which can be found within the runMatchFakes script. An example
command for running this script is demonstrated below.

.. code-block:: bash

    runMatchFakes.py <input repository> 9813 -f HSC-G -o ~/example_dir/match -c ~/customFakeGalaxyCatalog.fits --ccd 2,2
